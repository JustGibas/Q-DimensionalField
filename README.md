# VR Exploration Game

## Development Model
This project uses an AI-assisted approach:
- **AI Models (GitHub Copilot):** Code generation and technical suggestions
- **Human Developer (Justinas Gibas):** Oversight, testing, and feedback

## Repository Structure
The project is limited to 10 source files:
1. index.html
2. README.md
3. config.js
4. game.js
5. components.js
6. managers.js
7. ui.js
8. styles.css
9. player.js
10. generators.js

## UI Architecture
The UI is managed via `ui.js` which defines:
- **UIUtils:** A namespace for common UI utility functions (e.g., `createDebugToggle`).
- **UIComponents:** Reusable components (like generic window structures).
- **UIManager:** Coordinates toolbar, windows, hotbar, and manages UI events.
  
The initialization is done in index.html where we first create the UIManager followed by game initialization.
  
## Game Flow

1. **Initialization:**
   - The game waits for the A-Frame scene and player rig to load.
   - Managers (StateManager, ChunkManager, VoxelManager, and UIManager) are initialized in sequence.
   - The world is generated by creating dynamic chunks based on the player's position. New chunks are loaded and distant ones are removed as the player moves.

2. **Game Loop:**
   - A continuous loop updates the player’s position, updates chunks around the player, and recalculates debug metrics (FPS, memory, draw calls).
   - Debug information is relayed to the UI for live monitoring.

3. **Event Handling:**
   - Input events (keyboard, mouse, VR controllers) are captured.
   - Pointer lock and drag events allow navigation and interaction with in-game UI windows.
   - The ESC key toggles the pause state and brings up the main menu.

## UI Sequence

1. **Loading Screen:**
   - A loading screen is displayed while assets and managers are being initialized.
   - Once all components are ready, the screen fades out.

2. **Toolbar and Windows:**
   - A fixed toolbar at the top of the view provides quick access buttons for Developer Tools, Inventory, Settings, and Main Menu.
   - Clicking a toolbar button toggles the corresponding window. Windows slide in/out with fade animations and are draggable.
   - Windows include:
     - **Developer Tools:** Displays debug information (player position, active chunks, performance metrics) and allows manipulation of debug flags.
     - **Settings:** Allows configuration of graphics, controls, and VR options.
     - **Inventory:** Provides a grid for managing in-game items.
     - **Main Menu:** Serves as the hub for new game, settings access, and exiting the game.

3. **In-Game Interaction:**
   - The UI dynamically updates based on game events.
   - Hover, drag, and click events are routed through a centralized UIManager ensuring smooth interactions and state synchronization.
   - The debug window continuously refreshes to give real-time feedback on game metrics.

## Technical Details

### Features & Requirements
- **Dynamic World:**  
  Procedurally generated voxel chunks that update based on player movement.
- **Robust UI Management:**  
  Layered UI elements with interactive toolbars, draggable windows, and VR/desktop compatibility.
- **Performance & Debugging:**  
  Real time FPS, memory, and draw call metrics displayed through the debug window.

### Architecture Diagram
```
World
├── Chunks (10x10x10)
│   ├── Blocks (1x1x1)
│   └── Voxels (0.1³)
└── Managers
    ├── ChunkManager
    ├── TextureManager
    └── WorldManager
```

### Implementation Details
- **Save System:**
  - Chunks: RGB-encoded height maps
  - World: Compressed binary data
  - Voxels: Run-length encoding

## Development Phases

### Phase 1 (Current)
- Implement RGB terrain encoding
- Test texture baking performance
- Optimize chunk generation

### Phase 2
- Enhance compression systems
- Implement proper LOD
- Add advanced culling

### Phase 3
- Polish visualization
- Optimize memory usage
- Deploy beta version

## Technical Notes

### RGB Encoding System
```javascript
// Example encoding structure
{
  red: heightData,    // 0-255 for height
  green: withData,    // 0-255 for
  blue: depthData,  // 0-255 for 
  alpha: typeData     // 0-255 for block types
}
```

### Development Setup
- Modern WebVR browser required
- Local HTTP server for module support
- Node.js for build tools

## Logging Improvements

### Overview
Logging has been improved across all parts of the game to provide detailed insights into the game's flow and operations. This includes extensive explanations for each logging statement and a flag to enable or disable logging.

### Logging Flag
A logging flag has been added to enable or disable logging. This flag can be found in the script section of `index.html` and in the `init` functions of various components.

### Enabling/Disabling Logging
To enable logging, set the `loggingEnabled` flag to `true`. To disable logging, set the flag to `false`.

### Examples of Logging Output
- Initialization of the A-Frame scene: `console.log('A-Frame scene loaded')`
- Loading of the world container: `console.log('World container status:', { childCount: container.children.length, children: Array.from(container.children).map(c => c.getAttribute('chunk')) })`
- Player rig setup: `console.log('Player rig setup complete')`

### Purpose of Logging
The purpose of logging is to provide developers with detailed insights into the game's flow and operations. This helps in debugging and understanding the game's behavior, making it easier to identify and fix issues.

## Inventory Ideas

### Overview
The inventory system will allow players to collect, store, and manage various items within the game. This includes resources, tools, and other objects that can be used for crafting, building, and exploration.

### Features
- **Item Collection:**
  - Players can collect items by interacting with the environment.
  - Items can be picked up, dropped, and transferred between inventory slots.
- **Inventory Slots:**
  - The inventory will have a limited number of slots for storing items.
  - Each slot can hold a specific type and quantity of item.
- **Crafting System:**
  - Players can combine items to create new tools, structures, and resources.
  - Crafting recipes will be available for players to discover and use.
- **Resource Management:**
  - Players must manage their resources effectively to survive and progress in the game.
  - Resources can be gathered from the environment and used for crafting and building.

### Implementation Details
- **UI Design:**
  - The inventory UI will be accessible through a menu or hotkey.
  - Items will be displayed in a grid layout with icons and descriptions.
- **Item Types:**
  - Common items: wood, stone, metal, food, etc.
  - Tools: pickaxe, axe, shovel, etc.
  - Special items: rare resources, unique tools, etc.
- **Interaction:**
  - Players can interact with the inventory using VR controllers or keyboard/mouse.
  - Drag-and-drop functionality for moving items between slots.
- **Persistence:**
  - Inventory data will be saved and loaded with the player's progress.
  - Items will be retained between game sessions.

### Future Enhancements
- **Advanced Crafting:**
  - More complex crafting recipes and item combinations.
  - Integration with the world generation system for unique resources.
- **Inventory Expansion:**
  - Additional inventory slots and storage options.
  - Backpacks, chests, and other storage containers.
- **Multiplayer Support:**
  - Shared inventory and trading between players.
  - Cooperative crafting and resource management.

## Known Issues & Troubleshooting

### Loading Screen Issues
The game may occasionally get stuck at the loading screen. This is typically caused by:
1. React JSX syntax errors in UI components
2. Race conditions during manager initialization
3. Missing passive event listeners in touch controls

#### Error Signatures
```
Uncaught SyntaxError: Unexpected token '<' (at ui.js:34:9)
[Violation] Added non-passive event listener to a scroll-blocking 'touchmove' event
Game initialization timeout - continuing without game instance
```

### Troubleshooting Steps

1. **Loading Screen Stuck**
   ```javascript
   // Check browser console for these specific errors:
   - SyntaxError: Unexpected token '<' 
   - [LoadingScreen] Component initialized
   - Game initialization timeout
   ```
   Solution: Ensure React is properly loaded before any JSX rendering

2. **Touch Event Warnings**
   ```javascript
   // Update touch event listeners with passive flag
   element.addEventListener('touchstart', handler, { passive: true });
   element.addEventListener('touchmove', handler, { passive: true });
   ```

3. **Game Instance Not Found**
   ```javascript
   // Add timeout and retry logic to game initialization
   await new Promise((resolve, reject) => {
     const checkGame = () => {
       if (window.game) resolve();
       else if (retries++ < maxRetries) setTimeout(checkGame, 100);
       else reject(new Error('Game initialization timeout'));
     };
     checkGame();
   });
   ```

### Initialization Sequence
```
1. A-Frame Scene Load
2. Player Controls Init
3. VR Controls Setup
4. Keyboard Controls Setup
5. LoadingScreen Manager
6. Game Instance Init
```

### Version Compatibility
```
A-Frame: 1.4.0 (2022-12-26)
THREE.js: ^0.147.0
WebVR Polyfill: ^0.10.12
```

## File Limit Notice

Due to project constraints, please do not exceed a 10–file limit when adding new source files.
Note: The index.html and README.md files also count toward this 10–file limit. no additional files alowed to create.

## For AI Models

### Project Context
This section is specifically for AI models participating in development:

- **Human Collaborator:** Justinas Gibas
  - Role: Project administrator, tester, and feedback provider
  - Responsibilities: Code review, testing, and validation

- **AI Model Responsibilities:**
  - Maintain documentation
  - Generate code suggestions
  - Update technical specifications
  - Follow established patterns
  - Respect file limits

### Communication Protocol
- Use this README as primary documentation
- Document all major decisions
- Maintain clear development phases
- Update technical notes as needed

### Project Constraints
- Maximum 10 files total (including index.html and README.md)
- Current files (10/10):
  1. index.html
  2. README.md
  3. config.js
  4. game.js
  5. components.js
  6. managers.js
  7. ui.js
  8. styles.css
  9. player.js
  10. generators.js

### File Dependencies
```
index.html
├── config.js
├── generators.js
├── managers.js
├── components.js
├── player.js
├── game.js
├── ui.js
└── styles.css
```

### Code Organization Rules
1. New features must be added to existing files
2. Use namespacing to organize code within files
3. Follow the established patterns for each file:
   - config.js: Constants and configuration
   - generators.js: World generation logic
   - managers.js: Game state management
   - components.js: A-Frame components
   - player.js: Player-related logic
   - game.js: Core game initialization
   - ui.js: UI components and management
   - styles.css: All styling

### Common Integration Points
1. StateManager (managers.js) for state changes
2. UIManager (ui.js) for UI updates
3. EventSystem through A-Frame's event system
4. CONFIG object (config.js) for settings

### Pattern Examples
```javascript
// Adding new feature to existing file
// In components.js:
AFRAME.registerComponent('new-feature', {
    schema: {
        // Properties
    },
    init() {
        // Initialization
    }
});
```

```javascript
// In managers.js:
class ExistingManager {
    newFeatureMethod() {
        // New functionality
    }
}
```

### When Suggesting Changes
1. Always specify the target file
2. Use existing patterns within that file
3. Maintain current dependency structure
4. Consider the 10-file limit

JG promts
improve, develop or fix one small thing prepering for the next one.